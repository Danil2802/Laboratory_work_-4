# –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ ‚Ññ4
## ¬´–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã¬ª
## –ø–æ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–µ: ¬´–ü—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ¬ª
### –¶–µ–ª–∏ –∏ –∑–∞–¥–∞—á–∏ —Ä–∞–±–æ—Ç—ã: –∏–∑—É—á–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤ –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤, –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ—Ç–ª–∞–¥–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Å—Å–∏–≤–æ–≤. 
### –ó–∞–¥–∞–Ω–∏–µ –∫ —Ä–∞–±–æ—Ç–µ: –ù–∞–ø–∏—Å–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º. 
### –ú–µ—Ç–æ–¥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã:
#### 1. –†–∞–∑—Ä–∞–±–æ—Ç–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏ –ø–æ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–º—É –∑–∞–¥–∞–Ω–∏—é. 
#### 2. –ù–∞–ø–∏—Å–∞—Ç—å –∏ –æ—Ç–ª–∞–¥–∏—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—É —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏. 
#### 3. –ü—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏—Å—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö.
### –ó–∞–¥–∞–Ω–∏—è:
### –ó–∞–¥–∞–Ω–∏–µ ‚Ññ1 ¬´–ú–µ—Ç–æ–¥—ã —Ä–µ—à–µ–Ω–∏—è –Ω–µ–ª–∏–Ω–µ–π–Ω—ã–π —É—Ä–∞–≤–Ω–µ–Ω–∏–π¬ª 
#### –û—Ç–¥–µ–ª–∏—Ç–µ –∫–æ—Ä–Ω–∏ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —É—Ä–∞–≤–Ω–µ–Ω–∏—è, —Å–æ–≥–ª–∞—Å–Ω–æ –≤–∞—Ä–∏–∞–Ω—Ç—É –∏–∑ —Ç–∞–±–ª.1, –∏ —É—Ç–æ—á–Ω–∏—Ç–µ –∏—Ö –æ–¥–Ω–∏–º –∏–∑ –º–µ—Ç–æ–¥–æ–≤ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ Œµ=10-4 . –†–µ—à–∏—Ç—å —É—Ä–∞–≤–Ω–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–º –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è, –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞ –∏ –º–µ—Ç–æ–¥–æ–º –ø—Ä–æ—Å—Ç—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π. –õ–∏–±–æ –¥—Ä—É–≥–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏, –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã–º–∏ –≤ —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–æ–π —á–∞—Å—Ç–∏ –∫ –∑–∞–¥–∞–Ω–∏—é
#### –í–∞—Ä–∏–∞–Ω—Ç 5 - ùë†ùëñùëõ( ùë• + 1) = 0.2 ùë•
#### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ mainq.cpp
```C++
#include <iostream>
#include <cmath>
#include <iomanip>
#include <chrono>
#include <vector>

const double EPSILON = 0.0001; // —Ç–æ—á–Ω–æ—Å—Ç—å
const int MAX_ITERATIONS = 20; // –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é
double f(double x) {
    return sin(x + 1) - 0.2 * x;
}

// –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞
double f_prime(double x) {
    return cos(x + 1) - 0.2;
}

// –í—Ç–æ—Ä–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
double f_double_prime(double x) {
    return -sin(x + 1);
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è x = asin(0.2x) - 1
double func1(double x) {
    return asin(0.2 * x) - 1;
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∞–∑–ª–æ–∂–µ–Ω–∏—è x = sin(x+1) / 0.2
double func2(double x) {
    return sin(x + 1) / 0.2;
}

// –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–∏ x = asin(0.2x) - 1
double derivativeFunc1(double x) {
    return 0.2 / sqrt(1 - pow(0.2 * x, 2));
}

// –ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–∏ x = sin(x+1) / 0.2
double derivativeFunc2(double x) {
    return cos(x + 1) / 0.2;
}

// –ú–µ—Ç–æ–¥ –ø—Ä–æ—Å—Ç—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
bool simpleIteration(double (*func)(double), double x0, double epsilon, int maxIterations, double& totalDuration, int& totalIterations, double& convergenceRate) {
    double x = x0;
    int iteration = 0;
    double lastX = x;
    double lastError = 0.0;

    // –í—ã–≤–æ–¥ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –∏—Ç–µ—Ä–∞—Ü–∏–π
    std::cout << std::setw(5) << "N"
        << std::setw(16) << "x_—Å—Ç–∞—Ä–æ–µ"
        << std::setw(14) << "x_–Ω–æ–≤–æ–µ"
        << std::setw(26) << "|x_–Ω–æ–≤–æ–µ-x_—Å—Ç–∞—Ä–æ–µ|"
        << std::setw(20) << "–°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏" << std::endl;

    auto start = std::chrono::high_resolution_clock::now();

    for (iteration = 0; iteration < maxIterations; ++iteration) {
        double newX = func(x);
        double diff = fabs(newX - x);

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        if (std::isnan(newX) || std::isnan(diff)) {
            std::cout << "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∫–æ—Ä–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω." << std::endl;
            return false;
        }

        double currentConvergenceRate = 0.0;
        if (iteration > 0) {
            currentConvergenceRate = diff / lastError;
        }
        lastError = diff;

        std::cout << std::setw(5) << iteration + 1
            << std::setw(15) << std::fixed << std::setprecision(4) << x
            << std::setw(15) << std::fixed << std::setprecision(4) << newX
            << std::setw(20) << std::fixed << std::setprecision(4) << diff
            << std::setw(20) << std::fixed << std::setprecision(4) << currentConvergenceRate << std::endl;

        if (diff < epsilon) {
            lastX = newX;
            convergenceRate += currentConvergenceRate;
            break;
        }

        x = newX;
        lastX = newX;
        convergenceRate += currentConvergenceRate;
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = end - start;
    totalDuration += duration.count();
    totalIterations += iteration;

    if (iteration < maxIterations) {
        std::cout << "–ù–∞–π–¥–µ–Ω –∫–æ—Ä–µ–Ω—å: x = " << std::fixed << std::setprecision(4) << lastX << " –ø–æ—Å–ª–µ " << iteration + 1 << " –∏—Ç–µ—Ä–∞—Ü–∏–π" << std::endl;
    }

    return iteration < maxIterations;
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω–µ–π
void checkConvergenceAndFindRoots() {
    std::cout << "\n–†–µ—à–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –ø—Ä–æ—Å—Ç—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π\n" << std::endl;
    std::cout << std::fixed << std::setprecision(4);

    double totalDuration = 0.0;
    int totalIterations = 0;
    double convergenceRateSum = 0.0;

    std::vector<double> xValues;
    for (double x = -10; x <= 10; x += 1) {
        xValues.push_back(x);
    }

    std::cout << "–ê–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–∞ x = asin(0.2x) - 1\n" << std::endl;
    for (double x : xValues) {
        double df1 = derivativeFunc1(x);

        std::cout << "x = " << std::fixed << std::setprecision(4) << x << ": ";
        if (fabs(df1) >= 1) {
            std::cout << "–ú–µ—Ç–æ–¥ –Ω–µ —Å—Ö–æ–¥–∏—Ç—Å—è (|–ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è| >= 1)." << std::endl;
        }
        else {
            std::cout << "–ú–µ—Ç–æ–¥ —Å—Ö–æ–¥–∏—Ç—Å—è, –≤—ã–ø–æ–ª–Ω—è–µ–º –∏—Ç–µ—Ä–∞—Ü–∏–∏." << std::endl;
            if (!simpleIteration(func1, x, EPSILON, MAX_ITERATIONS, totalDuration, totalIterations, convergenceRateSum)) {
                std::cout << "–ú–µ—Ç–æ–¥ –Ω–µ –Ω–∞—à–µ–ª –∫–æ—Ä–µ–Ω—å –ø–æ—Å–ª–µ " << MAX_ITERATIONS << " –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;
            }
        }

        std::cout << "\n\n";
    }

    std::cout << "–ê–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–∞ x = sin(x + 1) / 0.2\n" << std::endl;
    for (double x : xValues) {
        double df2 = derivativeFunc2(x);

        std::cout << "x = " << std::fixed << std::setprecision(4) << x << ": ";
        if (fabs(df2) >= 1) {
            std::cout << "–ú–µ—Ç–æ–¥ –Ω–µ —Å—Ö–æ–¥–∏—Ç—Å—è (|–ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è| >= 1)." << std::endl;
        }
        else {
            std::cout << "–ú–µ—Ç–æ–¥ —Å—Ö–æ–¥–∏—Ç—Å—è, –≤—ã–ø–æ–ª–Ω—è–µ–º –∏—Ç–µ—Ä–∞—Ü–∏–∏." << std::endl;
            if (!simpleIteration(func2, x, EPSILON, MAX_ITERATIONS, totalDuration, totalIterations, convergenceRateSum)) {
                std::cout << "–ú–µ—Ç–æ–¥ –Ω–µ –Ω–∞—à–µ–ª –∫–æ—Ä–µ–Ω—å –ø–æ—Å–ª–µ " << MAX_ITERATIONS << " –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;
            }
        }

        std::cout << "\n\n";
    }

    std::cout << "–°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–∂–¥–µ–Ω–∏—è: " << std::endl;
    std::cout << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –≤—Å–µ–≥–æ: " << totalIterations << std::endl;
    std::cout << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ä–µ–º–µ–Ω–∏ –æ–±—â–µ–µ: " << totalDuration << " —Å–µ–∫—É–Ω–¥" << std::endl;
    std::cout << "–°—Ä–µ–¥–Ω—è—è —Å–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏: " << "y = " << (totalIterations > 0 ? convergenceRateSum / totalIterations : 0.0) << "x" << std::endl;
}

// –ú–µ—Ç–æ–¥ –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è
void bisection(double a, double b, int q, int& total_iterations, double& total_time) {
    auto start = std::chrono::high_resolution_clock::now(); // –ù–∞—á–∞–ª–æ –∑–∞–º–µ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏

    double c;
    int n = 1;

    std::cout << "\n–ú–µ—Ç–æ–¥ –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è –¥–ª—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ [" << std::fixed << std::setprecision(4)
        << a << "; " << b << "]" << std::endl;
    std::cout << "N\tc\t\ta\t\tb\t\t|b - a|" << std::endl;

    for (n = 1; (b - a) / 2.0 > EPSILON; ++n) {
        c = (a + b) / 2.0;

        std::cout << n << "\t" << std::fixed << std::setprecision(4) << c << "\t\t"
            << a << "\t\t" << b << "\t\t" << (b - a) << std::endl;

        if (std::abs(f(c)) < EPSILON) {
            a = c;
            std::cout << ++n << "\t" << std::fixed << std::setprecision(4) << c << "\t\t"
                << a << "\t\t" << b << "\t\t" << (b - a) << std::endl;

            std::cout << "–ö–æ—Ä–µ–Ω—å –Ω–∞–π–¥–µ–Ω: " << c << " –ø–æ—Å–ª–µ " << n << " –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;

            total_iterations += n;
            auto end = std::chrono::high_resolution_clock::now();
            std::chrono::duration<double> elapsed = end - start;
            total_time += elapsed.count();

            return;
        }

        if (f(c) * f(a) < 0) {
            b = c;
        }
        else {
            a = c;
        }
    }

    std::cout << "–ö–æ—Ä–µ–Ω—å –Ω–∞–π–¥–µ–Ω: " << (a + b) / 2.0 << " –ø–æ—Å–ª–µ " << n << " –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;

    total_iterations += n;
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    total_time += elapsed.count();
}

// –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞
void newton(double x0, int max_iter, int& total_iterations, double& total_time) {
    auto start = std::chrono::high_resolution_clock::now(); // –ù–∞—á–∞–ª–æ –∑–∞–º–µ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏

    double x = x0;
    int n = 1;

    std::cout << "\n–ù–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ x0 = " << std::fixed << std::setprecision(4) << x0 << std::endl;
    std::cout << "N\tx\t\tf(x)\t\tf'(x)\t\t|f(x)/f'(x)|" << std::endl;

    // –í—ã–≤–æ–¥ –Ω–∞—á–∞–ª—å–Ω–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
    double fx = f(x);
    double fpx = f_prime(x);
    std::cout << n << "\t" << std::fixed << std::setprecision(4) << x << "\t\t"
        << fx << "\t\t" << fpx << "\t\t" << std::abs(fx / fpx) << std::endl;

    for (; std::abs(fx / fpx) > EPSILON && n < max_iter; ++n) {
        if (fpx == 0) {
            std::cout << "–ü—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è —Ä–∞–≤–Ω–∞ –Ω—É–ª—é. –ú–µ—Ç–æ–¥ –Ω–µ –ø—Ä–∏–º–µ–Ω–∏–º." << std::endl;
            break;
        }

        x = x - fx / fpx;
        fx = f(x);
        fpx = f_prime(x);

        std::cout << n + 1 << "\t" << std::fixed << std::setprecision(4) << x << "\t\t"
            << fx << "\t\t" << fpx << "\t\t" << std::abs(fx / fpx) << std::endl;
    }

    if (n == max_iter) {
        std::cout << "–î–æ—Å—Ç–∏–≥–Ω—É—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;
    }
    else {
        std::cout << "–ö–æ—Ä–µ–Ω—å –Ω–∞–π–¥–µ–Ω: " << x << " –ø–æ—Å–ª–µ " << n << " –∏—Ç–µ—Ä–∞—Ü–∏–π." << std::endl;
    }

    total_iterations += n;
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    total_time += elapsed.count();
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤ –∏ –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–Ω–µ–π
void find_roots() {
    double Alfa = -10;
    double Beta = 10;
    int max_iter = 100; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π
    int total_iterations = 0;
    double total_time = 0.0;
    double K = (std::abs(Alfa) + std::abs(Beta)) / 2;

    // –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è
    std::cout << "–†–µ—à–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è" << std::endl;
    for (int q = 0; q < 10; ++q) {
        double a = Alfa + q * (Beta - Alfa) / K;
        double b = Alfa + (q + 1) * (Beta - Alfa) / K;

        if (f(a) * f(b) < 0) {
            bisection(a, b, q, total_iterations, total_time);
        }
        else {
            std::cout << "\n–ö–æ—Ä–Ω–µ–π –Ω–µ—Ç –Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [" << std::fixed << std::setprecision(4)
                << a << "; " << b << "]" << std::endl;
        }
    }
    std::cout << "\n–°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –º–µ—Ç–æ–¥–∞ –ø–æ–ª–æ–≤–∏–Ω–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è: " << std::endl;
    std::cout << "\n–û–±—â–µ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: " << std::fixed << std::setprecision(4)
        << total_time << " —Å–µ–∫—É–Ω–¥" << std::endl;
    std::cout << "–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π: " << total_iterations << std::endl;
    std::cout << "–ü–∞—Ä–∞–º–µ—Ç—Ä —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏: y = 0.5x " << std::endl;

    // –¢–µ–ø–µ—Ä—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞
    total_iterations = 0;
    total_time = 0.0;
    std::cout << "\n–†–µ—à–µ–Ω–∏–µ –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞" << std::endl;

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ t –¥–ª—è –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞
    double M2 = 0.0;
    double m1 = std::abs(f_prime(Alfa));
    for (double x = Alfa; x <= Beta; x += 1.0) {
        double fppx = std::abs(f_double_prime(x));
        double fpx = std::abs(f_prime(x));

        if (fppx > M2) M2 = fppx;
        if (fpx < m1) m1 = fpx;
    }
    double t = M2 / (2 * m1);

    for (int q = 0; q < 10; ++q) {
        double a = Alfa + q * (Beta - Alfa) / K;
        double b = Alfa + (q + 1) * (Beta - Alfa) / K;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å–ª–∏ a —Ä–∞–≤–Ω–æ 0, –∑–∞–º–µ–Ω–∏—Ç—å –µ–≥–æ –Ω–∞ 0.1
        if (a == 0) {
            a = 1.0;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ª–µ–∂–∏—Ç –ª–∏ –∫–æ—Ä–µ–Ω—å –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [a, b]
        if (f(a) * f(b) < 0) {
            std::cout << "\n–ö–æ—Ä–µ–Ω—å –ª–µ–∂–∏—Ç –≤ –æ—Ç—Ä–µ–∑–∫–µ [" << a << "; " << b << "]. –ù–∞—á–∏–Ω–∞–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ—Ä–Ω—è." << std::endl;
            newton(a, max_iter, total_iterations, total_time);
        }
        else {
            std::cout << "\n–ö–æ—Ä–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–µ [" << std::fixed << std::setprecision(4) << a << "; " << std::fixed << std::setprecision(4) << b << "]." << std::endl;
        }
    }

    std::cout << "\n–°–∫–æ—Ä–æ—Å—Ç—å —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –º–µ—Ç–æ–¥–∞ –ù—å—é—Ç–æ–Ω–∞: " << std::endl;
    std::cout << "\n–û–±—â–µ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: " << std::fixed << std::setprecision(4)
        << total_time << " —Å–µ–∫—É–Ω–¥" << std::endl;
    std::cout << "–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Ç–µ—Ä–∞—Ü–∏–π: " << total_iterations << std::endl;
    std::cout << "–ü–∞—Ä–∞–º–µ—Ç—Ä —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏: y = " << std::fixed << std::setprecision(4) << t << "x^2" << std::endl;
}

int main() {
    setlocale(LC_ALL, "Russian");
    find_roots(); // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–Ω–µ–π
    checkConvergenceAndFindRoots();
    return 0;
}
```
#### –†–µ—à–µ–Ω–∏–µ 1 –∑–∞–¥–∞—á–∏ –Ω–∞ —è–∑—ã–∫–µ Java –≤ maina.txt
### –ó–∞–¥–∞–Ω–∏–µ ‚Ññ2 ¬´–í—ã—á–∏—Å–ª–µ–Ω–∏—è –≤ –æ–¥–Ω–æ–º–µ—Ä–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞—Ö¬ª
#### –í–∞—Ä–∏–∞–Ω—Ç 5 ‚Äì –∞–ª–≥–æ—Ä–∏—Ç–º ranlux24_base; –≤–∞—Ä–∏–∞–Ω—Ç 15 - 
#### 1. –ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –≤ –∫–æ—Ç–æ—Ä–æ–π –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –º–∞—Å—Å–∏–≤ –∏–∑ ùëõ —á–∏—Å–µ–ª (ùëõ ‚â• 10) –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å–ª—É—á–∞–π–Ω—ã–º–∏ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏ –∏–∑ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [100, 900]. 
#### 2.  –í–≤–µ–¥–∏—Ç–µ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ —á–∏—Å–ª–æ ùê¥ –∏ –Ω–∞–π–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞ –∏–∑ –ø—É–Ω–∫—Ç–∞ 1, –±–æ–ª—å—à–∏—Ö ùê¥. –í—ã—á–∏—Å–ª–∏—Ç–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ –º–æ–¥—É–ª—é —ç–ª–µ–º–µ–Ω—Ç–∞. 
#### 3. –ü–æ–º–µ–Ω—è–π—Ç–µ –≤ –º–∞—Å—Å–∏–≤–µ –∏–∑ –ø—É–Ω–∫—Ç–∞ 1 –º–µ—Å—Ç–∞–º–∏ –ø–æ–ø–∞—Ä–Ω–æ —Å–æ—Å–µ–¥–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã, –µ—Å–ª–∏ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ —Å —á—ë—Ç–Ω—ã–º –Ω–æ–º–µ—Ä–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ—Å—è—Ç–∫–æ–≤ –±–æ–ª—å—à–µ, —á–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ—Ç–µ–Ω. –ï—Å–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–µ—á—ë—Ç–Ω–æ–µ, –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –Ω–µ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç—Å—è. 
#### 4. –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –º–∞—Å—Å–∏–≤ –∏–∑ ùëõ —á–∏—Å–µ–ª (ùëõ ‚â• 15) —Å–ª—É—á–∞–π–Ω—ã–º–∏ —Ü–µ–ª—ã–º–∏ —á–∏—Å–ª–∞–º–∏ –∏–∑ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [10, 20]. –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ, –∫–∞–∫–æ–π –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è –Ω–∞–∏–±–æ–ª—å—à–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑. 
#### 5. –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ –º–∞—Å—Å–∏–≤ —Å–ª—É—á–∞–π–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏. –í—ã—á–∏—Å–ª–∏—Ç–µ —Å—É–º–º—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞. –ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –º–µ–Ω—è—é—â—É—é –º–µ—Å—Ç–∞–º–∏ —Ü–∏—Ñ—Ä—ã –≤ —ç–ª–µ–º–µ–Ω—Ç–∞—Ö –º–∞—Å—Å–∏–≤–∞ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, 9164 ‚Üí 9641). –û—Ç—Å–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –º–∞—Å—Å–∏–≤ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è. –í—ã—á–∏—Å–ª–∏—Ç–µ —Å—É–º–º—É —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞ –∏ —Å—Ä–∞–≤–Ω–∏—Ç–µ —Å —Å—É–º–º–æ–π —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞.
#### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ mainw.cpp
```C++
#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <cmath>
#include <map>
#include <numeric>
#include <string>
#include <chrono>
#include <iomanip>
#include <cctype> // –î–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ std::isdigit
#include <sstream> // –î–ª—è —Ñ—É–Ω–∫—Ü–∏–∏ std::istringstream

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [min, max]
double generate_random_double(std::ranlux24_base& generator, double min, double max) {
    std::uniform_real_distribution<double> distribution(min, max);
    return distribution(generator);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [min, max]
int generate_random_int(std::ranlux24_base& generator, int min, int max) {
    std::uniform_int_distribution<int> distribution(min, max);
    return distribution(generator);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –±–æ–ª—å—à–∏—Ö A
int count_greater_than(const std::vector<double>& arr, double A) {
    return std::count_if(arr.begin(), arr.end(), [A](double x) { return x > A; });
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ –º–æ–¥—É–ª—é —ç–ª–µ–º–µ–Ω—Ç–∞
long double product_after_max_abs(const std::vector<double>& arr) {
    if (arr.empty()) return 0;

    auto max_abs_it = std::max_element(arr.begin(), arr.end(),
        [](double a, double b) { return std::abs(a) < std::abs(b); });

    long double product = 1;
    if (max_abs_it + 1 != arr.end()) {
        for (auto it = max_abs_it + 1; it != arr.end(); ++it) {
            product *= *it;
        }
    }
    return product;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
void swap_elements(std::vector<double>& arr) {
    for (size_t i = 0; i < arr.size() - 1; i += 2) {
        int tens = static_cast<int>(arr[i]) / 10 % 10;
        int hundreds = static_cast<int>(arr[i]) / 100;
        if (tens > hundreds) {
            std::swap(arr[i], arr[i + 1]);
        }
    }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–≥–æ—Å—è —ç–ª–µ–º–µ–Ω—Ç–∞
int most_frequent_element(const std::vector<int>& arr) {
    std::map<int, int> frequency;
    for (int num : arr) {
        ++frequency[num];
    }

    return std::max_element(frequency.begin(), frequency.end(),
        [](const std::pair<int, int>& a, const std::pair<int, int>& b) {
            return a.second < b.second;
        })->first;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Ü–∏—Ñ—Ä —á–∏—Å–ª–∞ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è
int sort_digits_desc(int num) {
    std::string num_str = std::to_string(num);
    std::sort(num_str.begin(), num_str.end(), std::greater<char>());
    return std::stoi(num_str);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ —á–∏—Å–ª–∞ –∏ –≤—ã–≤–æ–¥–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ 46*10^30
void print_scientific_notation(long double num) {
    if (num == 0) {
        std::cout << "0\n";
        return;
    }

    int exponent = 0;

    for (; num >= 10.0; ++exponent) {
        num /= 10.0;
    }

    for (; num < 1.0; --exponent) {
        num *= 10.0;
    }

    std::cout << std::fixed << std::setprecision(2) << num << " * 10^" << exponent << std::endl;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–≤–æ–¥–∞ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
double input_valid_number() {
    std::string input;
    bool valid = false;

    for (; !valid;) {
        std::cout << "–í–≤–µ–¥–∏—Ç–µ –æ–¥–Ω–æ —Å–ª–æ–≤–æ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã: ";
        std::getline(std::cin, input);

        std::istringstream stream(input);
        std::vector<std::string> words{ std::istream_iterator<std::string>{stream},
                                       std::istream_iterator<std::string>{} };

        if (words.size() != 1) {
            std::cout << "–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ –æ–¥–Ω–æ —Å–ª–æ–≤–æ.\n";
            continue;
        }

        valid = true; // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –≤–≤–æ–¥ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π, –ø–æ–∫–∞ –Ω–µ –¥–æ–∫–∞–∂–µ–º –æ–±—Ä–∞—Ç–Ω–æ–≥–æ

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π —Å–∏–º–≤–æ–ª –≤ —Å—Ç—Ä–æ–∫–µ
        for (char ch : input) {
            if (!std::isdigit(ch)) {
                valid = false; // –ï—Å–ª–∏ —Å–∏–º–≤–æ–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ü–∏—Ñ—Ä–æ–π, –ø–æ–º–µ—á–∞–µ–º –≤–≤–æ–¥ –∫–∞–∫ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π
                break;
            }
        }

        if (!valid) {
            std::cout << "–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã.\n";
        }
    }

    return std::stod(input);
}

int main() {
    setlocale(LC_ALL, "Russian");
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª —Å —Ç–µ–∫—É—â–∏–º –≤—Ä–µ–º–µ–Ω–µ–º –≤ –∫–∞—á–µ—Å—Ç–≤–µ seed
    auto seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::ranlux24_base generator(seed);

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
    int n1 = generate_random_int(generator, 10, 50);
    std::vector<double> array1(n1);
    for (auto& num : array1) {
        num = generate_random_double(generator, 100.0, 900.0);
    }

    std::cout << "–ú–∞—Å—Å–∏–≤ –∏–∑ —Å–ª—É—á–∞–π–Ω—ã—Ö –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª (" << n1 << " —ç–ª–µ–º–µ–Ω—Ç–æ–≤):\n";
    for (const auto& num : array1) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // –í–≤–æ–¥ —á–∏—Å–ª–∞ A –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –º–∞—Å—Å–∏–≤–∞
    double A = input_valid_number();
    std::cout << "–í—ã –≤–≤–µ–ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ: " << A << std::endl;

    int count_greater_A = count_greater_than(array1, A);
    std::cout << "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –±–æ–ª—å—à–∏—Ö A: " << count_greater_A << std::endl;

    long double product_after_max = product_after_max_abs(array1);
    std::cout << "–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ –º–æ–¥—É–ª—é: ";
    print_scientific_notation(product_after_max);

    // –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –º–∞—Å—Å–∏–≤–∞
    swap_elements(array1);
    std::cout << "–ú–∞—Å—Å–∏–≤ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏:\n";
    for (const auto& num : array1) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
    int n2 = generate_random_int(generator, 15, 100);
    std::vector<int> array2(n2);
    for (auto& num : array2) {
        num = generate_random_int(generator, 10, 20);
    }

    std::cout << "–ú–∞—Å—Å–∏–≤ –∏–∑ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª (" << n2 << " —ç–ª–µ–º–µ–Ω—Ç–æ–≤):\n";
    for (const auto& num : array2) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    int most_frequent = most_frequent_element(array2);
    std::cout << "–ù–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–π—Å—è —ç–ª–µ–º–µ–Ω—Ç: " << most_frequent << std::endl;

    // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
    int n3 = generate_random_int(generator, 20, 200);
    std::vector<int> array3(n3);
    for (auto& num : array3) {
        num = generate_random_int(generator, 1, 10000);
    }

    std::cout << "–ù–æ–≤—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ —Å–ª—É—á–∞–π–Ω—ã—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª (" << n3 << " —ç–ª–µ–º–µ–Ω—Ç–æ–≤):\n";
    for (const auto& num : array3) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    int initial_sum = std::accumulate(array3.begin(), array3.end(), 0);
    std::cout << "–°—É–º–º–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞: " << initial_sum << std::endl;

    // –ú–µ–Ω—è–µ–º —Ü–∏—Ñ—Ä—ã –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è
    for (auto& num : array3) {
        num = sort_digits_desc(num);
    }

    std::cout << "–ú–∞—Å—Å–∏–≤ –ø–æ—Å–ª–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–∏—Ñ—Ä –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è:\n";
    for (const auto& num : array3) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è
    std::sort(array3.begin(), array3.end(), std::greater<int>());
    std::cout << "–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è:\n";
    for (const auto& num : array3) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    int sorted_sum = std::accumulate(array3.begin(), array3.end(), 0);
    std::cout << "–°—É–º–º–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞: " << sorted_sum << std::endl;

    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å—É–º–º –∏ –≤—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    if (sorted_sum > initial_sum) {
        std::cout << "–°—É–º–º–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –±–æ–ª—å—à–µ —Å—É–º–º—ã –¥–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏." << std::endl;
    }
    else if (sorted_sum < initial_sum) {
        std::cout << "–°—É–º–º–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –º–µ–Ω—å—à–µ —Å—É–º–º—ã –¥–æ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏." << std::endl;
    }
    else {
        std::cout << "–°—É–º–º—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–æ –∏ –ø–æ—Å–ª–µ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ —Ä–∞–≤–Ω—ã." << std::endl;
    }
    return 0;
}
```
#### –†–µ—à–µ–Ω–∏–µ 2 –∑–∞–¥–∞—á–∏ –Ω–∞ —è–∑—ã–∫–µ Java –≤ mains.txt
### –ó–∞–¥–∞–Ω–∏–µ ‚Ññ3 ¬´–†–∞–±–æ—Ç–∞ —Å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞–º–∏ —Ä–∞–Ω–¥–æ–º–Ω—ã—Ö —á–∏—Å–µ–ª¬ª 
#### –ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞ —è–∑—ã–∫–µ C++. –í —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –≤–∞—Ä–∏–∞–Ω—Ç–æ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø–∏—Å–∞—Ç—å —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞, —Å –ø–æ–º–æ—â—å—é —ç—Ç–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç—å 3 –º–∞—Å—Å–∏–≤–∞ —Ä–∞–∑–º–µ—Ä–æ–º 50, 100 –∏ 1000 —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ —á–∏—Å–ª–∞–º–∏ –æ—Ç 1 –¥–æ 100. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫—Ä–∏—Ç–µ—Ä–∏–π —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–∏–ø–æ—Ç–µ–∑—ã –æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ –≤—ã–±–æ—Ä–∫–∏. –ó–Ω–∞—á–µ–Ω–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏—è —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç –¥–ª—è –∫–∞–∂–¥–æ–π –∏–∑ –≤—ã–±–æ—Ä–æ–∫ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –ø–æ —Ñ–æ—Ä–º—É–ª–µ: —Ö^2=—Å—É–º–º–∞((v1-v2)^2)/v2), –≥–¥–µ v1 - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –ø–æ–ø–∞–≤—à–∏—Ö –≤ i-—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, v2 - –æ–∂–∏–¥–∞–µ–º–æ–µ —á–∏—Å–ª–æ –ø–æ–ø–∞–¥–∞–Ω–∏–π –≤ i-—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª. –í–∞—Ä–∏–∞–Ω—Ç 5 - –∞–ª–≥–æ—Ä–∏—Ç–º ranlux24_base
#### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ maine.cpp
```C++
#include <iostream>
#include <vector>
#include <random>
#include <cmath>
#include <numeric>
#include <iomanip> // –î–ª—è –±–æ–ª–µ–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª –≤ —Ä–∞–º–∫–∞—Ö –æ—Ç 1 –¥–æ 100
std::vector<double> generate_normal_distribution(int size, double mean, double stddev) {
    std::random_device rd;
    std::ranlux24_base gen(rd());
    std::normal_distribution<> d(mean, stddev);

    std::vector<double> data(size);
    for (auto& number : data) {
        for (;;) {
            number = d(gen);
            if (number >= 1 && number <= 100) {
                break;
            }
        }
    }
    return data;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∫—Ä–∏—Ç–µ—Ä–∏—è —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç
double calculate_chi_square(const std::vector<double>& data, int num_intervals, double mean, double stddev, std::vector<int>& intervals) {
    double interval_width = (100.0 - 1.0) / num_intervals;

    for (double value : data) {
        if (value >= 1 && value <= 100) {
            int interval = static_cast<int>((value - 1) / interval_width);
            intervals[interval]++;
        }
    }

    double expected = data.size() / num_intervals;
    double chi_square = 0;

    for (int count : intervals) {
        chi_square += pow(count - expected, 2) / expected;
    }

    return chi_square;
}

int main() {
    setlocale(LC_ALL, "Russian");
    const std::vector<int> sizes = { 50, 100, 1000 };
    const double mean = 50.5; // –°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —á–∏—Å–µ–ª –æ—Ç 1 –¥–æ 100
    const double stddev = 29.0; // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –¥–ª—è —á–∏—Å–µ–ª –æ—Ç 1 –¥–æ 100
    const int num_intervals = 10; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤ –¥–ª—è –∫—Ä–∏—Ç–µ—Ä–∏—è —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç

    for (int size : sizes) {
        std::vector<double> data = generate_normal_distribution(size, mean, stddev);

        std::vector<int> intervals(num_intervals, 0);
        double chi_square = calculate_chi_square(data, num_intervals, mean, stddev, intervals);

        double real_mean = std::accumulate(data.begin(), data.end(), 0.0) / data.size();

        std::cout << "–†–∞–∑–º–µ—Ä –≤—ã–±–æ—Ä–∫–∏: " << size << std::endl;
        std::cout << "–ó–Ω–∞—á–µ–Ω–∏–µ –∫—Ä–∏—Ç–µ—Ä–∏—è —Ö–∏-–∫–≤–∞–¥—Ä–∞—Ç: " << chi_square << std::endl;
        std::cout << "–û–∂–∏–¥–∞–µ–º–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: " << mean << std::endl;
        std::cout << "–†–µ–∞–ª—å–Ω–æ–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: " << real_mean << std::endl;

        std::cout << "–ò–Ω—Ç–µ—Ä–≤–∞–ª—ã: " << num_intervals << std::endl;
        std::cout << "–®–∏—Ä–∏–Ω–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞: " << (100.0 - 1.0) / num_intervals << std::endl;

        // –í—ã–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö –∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
        std::cout << "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —á–∏—Å–ª–∞: ";
        for (double value : data) {
            std::cout << std::fixed << std::setprecision(2) << value << " ";
        }
        std::cout << std::endl;

        for (int i = 0; i < num_intervals; ++i) {
            double interval_start = 1.0 + i * ((100.0 - 1.0) / num_intervals);
            double interval_end = interval_start + ((100.0 - 1.0) / num_intervals);
            std::cout << "–ò–Ω—Ç–µ—Ä–≤–∞–ª " << i + 1 << " [" << interval_start << ", " << interval_end << "): ";
            std::cout << intervals[i] << " —á–∏—Å–µ–ª" << std::endl;
        }

        std::cout << "–†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–∏–ø–æ—Ç–µ–∑—ã: ";
        if (chi_square < 15) {
            std::cout << "–ì–∏–ø–æ—Ç–µ–∑–∞ –ø—Ä–∏–Ω—è—Ç–∞" << std::endl;
        }
        else {
            std::cout << "–ì–∏–ø–æ—Ç–µ–∑–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞" << std::endl;
        }

        std::cout << std::endl;
    }

    return 0;
}
```
### –ó–∞–¥–∞–Ω–∏–µ ‚Ññ4 ¬´–î–∏–ª–µ–º–º–∞ –∑–∞–∫–ª—é—á–µ–Ω–Ω–æ–≥–æ¬ª 
#### –¢—Ä–µ–±—É–µ—Ç—Å—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏–≥—Ä—É ¬´–ü—Ä–µ–¥–∞—Ç—å –∏–ª–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞—Ç—å¬ª –∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å 3 –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è –≤ –∏–≥—Ä–µ. 
#### –ò–≥—Ä–∞ —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∫–æ–ª-–≤–∞ —Ä–∞—É–Ω–¥–æ–≤ –æ—Ç 100 –¥–æ 200 (–∏—Ç–æ–≥–æ–≤–æ–µ –∫–æ–ª-–≤–æ —Ä–∞—É–Ω–¥–æ–≤ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –∑–∞–ø—É—Å–∫–µ –∏–≥—Ä—ã –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω–æ). –ù–∞ –ø—Ä–æ—Ç—è–∂–µ–Ω–∏–∏ –∏–≥—Ä–æ–≤–æ–π —Å–µ—Å—Å–∏–∏ —Å—Ä–∞–∂–∞—é—Ç—Å—è 2 –∞–ª–≥–æ—Ä–∏—Ç–º–∞. –í –∫–∞–∂–¥–æ–º —Ä–∞—É–Ω–¥–µ –∫–∞–∂–¥—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã–±–∏—Ä–∞–µ—Ç, –ª–∏–±–æ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ, –ª–∏–±–æ –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ. –ï—Å–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º –ê –≤—ã–±–∏—Ä–∞–µ—Ç –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ –∏ –∞–ª–≥–æ—Ä–∏—Ç–º –ë –≤—ã–±–∏—Ä–∞–µ—Ç –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ –æ–Ω–∏ –ø–æ–ª—É—á–∞—é—Ç –ø–æ 4 –æ—á–∫–∞. –ï—Å–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º –ê –≤—ã–±–∏—Ä–∞–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ, –∞ –∞–ª–≥–æ—Ä–∏—Ç–º –ë –≤—ã–±–∏—Ä–∞–µ—Ç –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ - –∞–ª–≥–æ—Ä–∏—Ç–º –ê –ø–æ–ª—É—á–∞–µ—Ç 0 –æ—á–∫–æ–≤, –∞ –∞–ª–≥–æ—Ä–∏—Ç–º –ë –ø–æ–ª—É—á–∞–µ—Ç 20 –æ—á–∫–æ–≤. –ï—Å–ª–∏ –æ–±–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≤—ã–±–∏—Ä–∞—é—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ –æ–±–∞ –ø–æ–ª—É—á–∞—é—Ç 24 –æ—á–∫–∞. –ö–∞–∂–¥–æ–º—É –∞–ª–≥–æ—Ä–∏—Ç–º—É –≤ –∫–∞–∂–¥–æ–º —Ä–∞—É–Ω–¥–µ –∏–∑–≤–µ—Å—Ç–Ω—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—Å–µ—Ö –ø—Ä–µ–¥—ã–¥—É—â–µ —Ä–∞—É–Ω–¥–æ–≤ —Ç–µ–∫—É—â–µ–π –∏–≥—Ä–æ–≤–æ–π —Å–µ—Å—Å–∏–∏, –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º –º–æ–∂–µ—Ç –≤—ã–±–∏—Ä–∞—Ç—å –±—É–¥–µ—Ç –æ–Ω —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞—Ç—å –∏–ª–∏ –ø—Ä–µ–¥–∞—Å—Ç. 
#### –ö–∞–∂–¥—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å –∏–∑ —Å–µ–±—è —Ñ—É–Ω–∫—Ü–∏—é —Å —Å–∏–≥–Ω–∞—Ç—É—Ä–æ–π: 
#### boolean func(int32 round_number, array[boolean] self_choices, array[boolean] enemy_choices) 
#### round_number ‚Äì –Ω–æ–º–µ—Ä —Ç–µ–∫—É—â–µ–≥–æ —Ä–∞—É–Ω–¥–∞ 
#### self_choices ‚Äì –º–∞—Å—Å–∏–≤ –±—É–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–±–æ—Ä–æ–≤ (–ø—Ä–µ–¥–∞—Ç—å –∏–ª–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞—Ç—å) –∑–∞ –≤—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ä–∞—É–Ω–¥—ã 
#### enemy_choices - –º–∞—Å—Å–∏–≤ –±—É–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–±–æ—Ä–æ–≤ (–ø—Ä–µ–¥–∞—Ç—å –∏–ª–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞—Ç—å) –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –∑–∞ –≤—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ä–∞—É–Ω–¥—ã 
#### true ‚Äì —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ 
#### false ‚Äì –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–æ 
#### –ö–∞–∂–¥–æ–º—É —Å—Ç—É–¥–µ–Ω—Ç—É –Ω—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å 3 –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É 3 —Ä–∞–∑–∞ —á—Ç–æ–±—ã –≤—ã—è–≤–∏—Ç—å –ª—É—á—à–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º. –õ—É—á—à–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –±—É–¥–µ—Ç —Å—Ä–∞–∂–∞—Ç—å—Å—è –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –±–∏—Ç–≤–µ –º–µ–∂–¥—É –≤—Å–µ–º–∏ —Å—Ç—É–¥–µ–Ω—Ç–∞–º–∏ –≥—Ä—É–ø–ø—ã –Ω–∞ –æ—á–Ω–æ–º –∑–∞–Ω—è—Ç–∏–∏.
#### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ mainr.cpp
```C++
#include <iostream>
#include <vector>
#include <random>
#include <utility>

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–≤–µ–¥–µ–Ω–∏—è
bool always_cooperate(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    return true; // –í—Å–µ–≥–¥–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç
}

bool always_betray(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    return false; // –í—Å–µ–≥–¥–∞ –ø—Ä–µ–¥–∞–µ—Ç
}

bool tit_for_tat(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    static bool betrayed_last = false;

    if (round_number == 0) {
        betrayed_last = false;
        return true; // –°–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç –≤ –ø–µ—Ä–≤–æ–º —Ä–∞—É–Ω–¥–µ
    }

    if (betrayed_last) {
        betrayed_last = false;
        return true; // –°–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç –ø–æ—Å–ª–µ –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º —Ä–∞—É–Ω–¥–µ
    }

    if (!enemy_choices.back()) {
        betrayed_last = true;
        return false; // –ü—Ä–µ–¥–∞–µ—Ç –ø–æ—Å–ª–µ –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤–∞ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞
    }

    return true; // –°–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç –≤ –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö
}

bool eye_for_two_eyes(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    static int betray_count = 0;
    static bool betrayed_last = false;

    if (round_number == 0) {
        betray_count = 0;
        betrayed_last = false;
        return true;
    }

    if (betrayed_last) {
        betrayed_last = false;
        betray_count = 0;
        return true;
    }

    if (!enemy_choices.back()) {
        betray_count++;
    }

    if (betray_count >= 2) {
        betray_count = 0;
        betrayed_last = true;
        return false;
    }

    return true; // –°–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç, –µ—Å–ª–∏ –Ω–µ –±—ã–ª–æ –¥–≤—É—Ö –ø—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤ –ø–æ–¥—Ä—è–¥
}

bool tricky(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    if (round_number == 0) return false; // –ü—Ä–µ–¥–∞–µ—Ç –≤ –ø–µ—Ä–≤–æ–º —Ä–∞—É–Ω–¥–µ
    return !enemy_choices.back(); // –ü—Ä–µ–¥–∞–µ—Ç, –µ—Å–ª–∏ —Å –Ω–∏–º —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞—é—Ç, —Å–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç, –µ—Å–ª–∏ –µ–≥–æ –ø—Ä–µ–¥–∞—é—Ç
}

bool vengeful(int round_number, const std::vector<bool>& self_choices, const std::vector<bool>& enemy_choices) {
    if (round_number == 0) return true; // –°–æ—Ç—Ä—É–¥–Ω–∏—á–∞–µ—Ç –≤ –ø–µ—Ä–≤–æ–º —Ä–∞—É–Ω–¥–µ
    return enemy_choices.back(); // –ü–æ–≤—Ç–æ—Ä—è–µ—Ç –≤—ã–±–æ—Ä –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ–¥–µ–Ω–∏—è –∏–≥—Ä—ã –º–µ–∂–¥—É –¥–≤—É–º—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞–º–∏
std::pair<int, int> play_game(bool (*alg1)(int, const std::vector<bool>&, const std::vector<bool>&),
    bool (*alg2)(int, const std::vector<bool>&, const std::vector<bool>&), int& num_rounds) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(100, 200);
    num_rounds = dist(gen);

    std::vector<bool> choices1, choices2;
    int score1 = 0, score2 = 0;

    for (int round = 0; round < num_rounds; ++round) {
        bool choice1 = alg1(round, choices1, choices2);
        bool choice2 = alg2(round, choices2, choices1);

        choices1.push_back(choice1);
        choices2.push_back(choice2);

        if (choice1 && choice2) {
            score1 += 24;
            score2 += 24;
        }
        else if (!choice1 && !choice2) {
            score1 += 4;
            score2 += 4;
        }
        else if (choice1 && !choice2) {
            score2 += 20;
        }
        else {
            score1 += 20;
        }

        // –í—ã–≤–æ–¥ —Ö–æ–¥–æ–≤ –∫–∞–∂–¥–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –≤ —Ç–µ–∫—É—â–µ–º —Ä–∞—É–Ω–¥–µ
        std::cout << "Round " << round + 1 << ": alg1 = " << (choice1 ? "Cooperate" : "Betray")
            << ", alg2 = " << (choice2 ? "Cooperate" : "Betray") << "\n";
    }

    return std::make_pair(score1, score2);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
void run_games() {
    // –ê–ª–≥–æ—Ä–∏—Ç–º—ã
    std::vector<bool (*)(int, const std::vector<bool>&, const std::vector<bool>&)> algorithms = {
        always_cooperate, always_betray, tit_for_tat, eye_for_two_eyes, tricky, vengeful
    };
    std::vector<std::string> names = {
        "Always Cooperate", "Always Betray", "Tit for Tat", "Eye for Two Eyes", "Tricky", "Vengeful"
    };
    const int num_games = 3;

    // –ò—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    std::vector<int> total_scores(algorithms.size(), 0);
    std::vector<double> overall_real_scores(algorithms.size(), 0.0);

    for (size_t i = 0; i < algorithms.size(); ++i) {
        for (size_t j = i + 1; j < algorithms.size(); ++j) {
            int total_score1 = 0, total_score2 = 0;
            double total_real_score1 = 0.0, total_real_score2 = 0.0;
            for (int game = 0; game < num_games; ++game) {
                std::cout << "Starting Game " << game + 1 << " between " << names[i] << " and " << names[j] << ":\n";
                int num_rounds = 0;
                std::pair<int, int> scores = play_game(algorithms[i], algorithms[j], num_rounds);
                int score1 = scores.first;
                int score2 = scores.second;

                total_score1 += score1;
                total_score2 += score2;
                std::cout << "Game " << game + 1 << " between " << names[i] << " and " << names[j] << ": "
                    << names[i] << " score: " << score1 << ", " << names[j] << " score: " << score2 << "\n";

                // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∏ –≤—ã–≤–æ–¥ —Ä–µ–∞–ª—å–Ω—ã—Ö –æ—á–∫–æ–≤ –ø–æ—Å–ª–µ –∏–≥—Ä—ã
                double real_score1 = (static_cast<double>(score1) / num_rounds) * 200;
                double real_score2 = (static_cast<double>(score2) / num_rounds) * 200;
                total_real_score1 += real_score1;
                total_real_score2 += real_score2;
                std::cout << "Real scores after Game " << game + 1 << ": " << names[i] << " score: " << real_score1
                    << ", " << names[j] << " score: " << real_score2 << "\n";
            }
            std::cout << "Total score for " << names[i] << " in " << num_games << " games: " << total_score1 << "\n";
            std::cout << "Total score for " << names[j] << " in " << num_games << " games: " << total_score2 << "\n";
            std::cout << "Total real score for " << names[i] << " in " << num_games << " games: " << total_real_score1 << "\n";
            std::cout << "Total real score for " << names[j] << " in " << num_games << " games: " << total_real_score2 << "\n\n";

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            total_scores[i] += total_score1;
            total_scores[j] += total_score2;
            overall_real_scores[i] += total_real_score1;
            overall_real_scores[j] += total_real_score2;
        }
    }

    // –í—ã–≤–æ–¥ –æ–±—â–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∫–∞–∂–¥–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
    std::cout << "Overall scores for all algorithms:\n";
    for (size_t i = 0; i < names.size(); ++i) {
        std::cout << names[i] << ": " << total_scores[i] << ", Overall real score: " << overall_real_scores[i] << "\n";
    }
}

int main() {
    run_games();
    return 0;
}
```
#### –†–µ—à–µ–Ω–∏–µ 4 –∑–∞–¥–∞—á–∏ –Ω–∞ —è–∑—ã–∫–µ Java –≤ maind.txt
### –ó–∞–¥–∞–Ω–∏–µ ‚Ññ5 ¬´–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª¬ª 
#### –ó–∞–¥–∞–Ω–∏–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –Ω–∞ —è–∑—ã–∫–µ C++. –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —á–∏—Å–µ–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º—ã (—Ç–∞–±–ª–∏—Ü–∞ 4): –í–∞—Ä–∏–∞–Ω—Ç 5 ‚Äì –∞–ª–≥–æ—Ä–∏—Ç–º RC4
#### –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ mainy.cpp
```C++
#include <iostream>
#include <vector>
#include <cstdint>
#include <random>
#include <cstring>

class RC4 {
public:
    RC4(const std::vector<uint8_t>& key) {
        initialize(key);
    }

    uint8_t generate() {
        i = (i + 1) % 256;
        j = (j + S[i]) % 256;
        std::swap(S[i], S[j]);
        uint8_t t = (S[i] + S[j]) % 256;
        return S[t];
    }

    void print_S_table() const {
        std::cout << "\nS table: ";
        for (auto s : S) {
            std::cout << static_cast<int>(s) << " ";
        }
        std::cout << std::endl;
    }

private:
    void initialize(const std::vector<uint8_t>& key) {
        uint8_t keyLength = key.size();
        for (int i = 0; i < 256; ++i) {
            S[i] = i;
        }
        uint8_t j = 0;
        for (int i = 0; i < 256; ++i) {
            j = (j + S[i] + key[i % keyLength]) % 256;
            std::swap(S[i], S[j]);
        }
    }

    std::vector<uint8_t> S = std::vector<uint8_t>(256);
    uint8_t i = 0, j = 0;
};

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–æ–≥–æ –∫–ª—é—á–∞
std::vector<uint8_t> generate_secure_key(size_t length) {
    std::vector<uint8_t> key(length);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 255);

    for (auto& byte : key) {
        byte = static_cast<uint8_t>(dis(gen));
    }

    return key;
}


int main() {
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ —Å—Ç–æ–π–∫–æ–≥–æ –∫–ª—é—á–∞ –¥–ª–∏–Ω–æ–π 16 –±–∞–π—Ç
    std::vector<uint8_t> key = generate_secure_key(16);

    // –í—ã–≤–æ–¥ –∫–ª—é—á–∞ (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏, –≤ —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ö –∫–ª—é—á –Ω–µ –¥–æ–ª–∂–µ–Ω –≤—ã–≤–æ–¥–∏—Ç—å—Å—è)
    std::cout << "Generated key: ";
    for (uint8_t byte : key) {
        std::cout << static_cast<int>(byte) << " ";
    }
    std::cout << std::endl;

    // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ RC4 —Å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∫–ª—é—á–æ–º
    RC4 rc4(key);

    // –í—ã–≤–æ–¥ —Ç–∞–±–ª–∏—Ü—ã S –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    rc4.print_S_table();

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –≤—ã–≤–æ–¥ 50 –ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
    std::cout << "\nGenerated pseudorandom numbers: ";
    for (int i = 0; i < 50; ++i) {
        std::cout << static_cast<int>(rc4.generate()) << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
